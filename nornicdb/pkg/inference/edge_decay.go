// Package inference - Edge decay for auto-generated relationships.
//
// Auto-generated edges (SIMILAR_TO, etc.) decay over time if not reinforced.
// This prevents the graph from accumulating stale relationships.
//
// Decay Model:
//
//	confidence_new = confidence_old * decay_rate ^ (days_since_access)
//
// Example:
//   - Edge created with 0.85 confidence
//   - Decay rate: 0.95 per day
//   - After 7 days without access: 0.85 * 0.95^7 = 0.60
//   - After 30 days: 0.85 * 0.95^30 = 0.18 (below threshold, removed)
//
// Usage:
//
//	decay := NewEdgeDecay(config, storage)
//	decay.Start(ctx) // Background worker
//	defer decay.Stop()
//
//	// Reinforce edge when accessed
//	decay.ReinforceEdge(edgeID)
package inference

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/orneryd/nornicdb/pkg/storage"
)

// EdgeDecayConfig configures the edge decay system.
type EdgeDecayConfig struct {
	// Enabled controls whether decay runs
	Enabled bool

	// DecayRate is the daily decay multiplier (0.0-1.0)
	// Lower = faster decay. Default: 0.95 (5% per day)
	DecayRate float64

	// MinConfidence is the threshold below which edges are deleted
	// Default: 0.3 (30%)
	MinConfidence float64

	// GracePeriod is how long to wait before applying decay to new edges
	// Default: 7 days
	GracePeriod time.Duration

	// ScanInterval is how often to scan for decayed edges
	// Default: 1 hour
	ScanInterval time.Duration

	// MaxEdgesPerScan limits edges processed per cycle (0 = unlimited)
	// Default: 1000
	MaxEdgesPerScan int

	// OnlyAutoGenerated if true, only decays auto-generated edges
	// Default: true (don't decay user-created edges)
	OnlyAutoGenerated bool

	// DryRun if true, logs what would be deleted without actually deleting
	// Default: false
	DryRun bool
}

// DefaultEdgeDecayConfig returns sensible defaults.
func DefaultEdgeDecayConfig() *EdgeDecayConfig {
	return &EdgeDecayConfig{
		Enabled:           true,
		DecayRate:         0.95,               // 5% decay per day
		MinConfidence:     0.3,                // Delete below 30%
		GracePeriod:       7 * 24 * time.Hour, // 7 days grace
		ScanInterval:      1 * time.Hour,
		MaxEdgesPerScan:   1000,
		OnlyAutoGenerated: true,
		DryRun:            false,
	}
}

// EdgeDecay manages automatic decay and removal of stale edges.
type EdgeDecay struct {
	config  *EdgeDecayConfig
	storage storage.Engine
	mu      sync.RWMutex

	// Track reinforced edges (edge ID -> last reinforced time)
	reinforced map[storage.EdgeID]time.Time

	// Background worker control
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup

	// Stats
	stats EdgeDecayStats
}

// EdgeDecayStats tracks decay operations.
type EdgeDecayStats struct {
	mu               sync.Mutex
	ScansCompleted   int64
	EdgesScanned     int64
	EdgesDecayed     int64
	EdgesDeleted     int64
	LastScanTime     time.Time
	LastScanDuration time.Duration
}

// NewEdgeDecay creates a new edge decay manager.
func NewEdgeDecay(config *EdgeDecayConfig, store storage.Engine) *EdgeDecay {
	if config == nil {
		config = DefaultEdgeDecayConfig()
	}

	return &EdgeDecay{
		config:     config,
		storage:    store,
		reinforced: make(map[storage.EdgeID]time.Time),
	}
}

// Start begins the background decay worker.
func (ed *EdgeDecay) Start(ctx context.Context) {
	ed.mu.Lock()
	defer ed.mu.Unlock()

	if !ed.config.Enabled {
		log.Println("[EDGE-DECAY] Disabled, not starting")
		return
	}

	ed.ctx, ed.cancel = context.WithCancel(ctx)
	ed.wg.Add(1)
	go ed.worker()

	log.Printf("[EDGE-DECAY] Started | decay_rate=%.2f min_conf=%.2f scan_interval=%v grace=%v",
		ed.config.DecayRate, ed.config.MinConfidence, ed.config.ScanInterval, ed.config.GracePeriod)
}

// Stop halts the background worker.
func (ed *EdgeDecay) Stop() {
	ed.mu.Lock()
	if ed.cancel != nil {
		ed.cancel()
	}
	ed.mu.Unlock()
	ed.wg.Wait()
	log.Println("[EDGE-DECAY] Stopped")
}

// ReinforceEdge marks an edge as recently accessed, resetting its decay.
// Call this when an edge is traversed or otherwise used.
func (ed *EdgeDecay) ReinforceEdge(edgeID storage.EdgeID) {
	ed.mu.Lock()
	defer ed.mu.Unlock()
	ed.reinforced[edgeID] = time.Now()
}

// GetStats returns current decay statistics.
func (ed *EdgeDecay) GetStats() EdgeDecayStats {
	ed.stats.mu.Lock()
	defer ed.stats.mu.Unlock()
	return EdgeDecayStats{
		ScansCompleted:   ed.stats.ScansCompleted,
		EdgesScanned:     ed.stats.EdgesScanned,
		EdgesDecayed:     ed.stats.EdgesDecayed,
		EdgesDeleted:     ed.stats.EdgesDeleted,
		LastScanTime:     ed.stats.LastScanTime,
		LastScanDuration: ed.stats.LastScanDuration,
	}
}

// TriggerScan manually triggers a decay scan (useful for testing).
func (ed *EdgeDecay) TriggerScan(ctx context.Context) (scanned, decayed, deleted int, err error) {
	return ed.scanAndDecay(ctx)
}

// worker runs the periodic decay scan.
func (ed *EdgeDecay) worker() {
	defer ed.wg.Done()

	ticker := time.NewTicker(ed.config.ScanInterval)
	defer ticker.Stop()

	// Initial delay to let system stabilize
	select {
	case <-time.After(30 * time.Second):
	case <-ed.ctx.Done():
		return
	}

	for {
		select {
		case <-ticker.C:
			scanned, decayed, deleted, err := ed.scanAndDecay(ed.ctx)
			if err != nil {
				log.Printf("[EDGE-DECAY] ❌ Scan error: %v", err)
			} else if deleted > 0 || decayed > 0 {
				log.Printf("[EDGE-DECAY] ✅ Scan complete | scanned=%d decayed=%d deleted=%d",
					scanned, decayed, deleted)
			}
		case <-ed.ctx.Done():
			return
		}
	}
}

// scanAndDecay performs one decay cycle.
func (ed *EdgeDecay) scanAndDecay(ctx context.Context) (scanned, decayed, deleted int, err error) {
	startTime := time.Now()

	// Get all edges (we need an iterator ideally, but for now use AllEdges if available)
	exporter, ok := ed.storage.(storage.ExportableEngine)
	if !ok {
		return 0, 0, 0, fmt.Errorf("storage does not support edge export")
	}

	edges, err := exporter.AllEdges()
	if err != nil {
		return 0, 0, 0, fmt.Errorf("failed to get edges: %w", err)
	}

	now := time.Now()
	toDelete := make([]storage.EdgeID, 0)

	for _, edge := range edges {
		if ctx.Err() != nil {
			break
		}

		// Respect scan limit
		if ed.config.MaxEdgesPerScan > 0 && scanned >= ed.config.MaxEdgesPerScan {
			break
		}

		scanned++

		// Skip non-auto-generated if configured
		if ed.config.OnlyAutoGenerated && !edge.AutoGenerated {
			continue
		}

		// Check grace period
		if now.Sub(edge.CreatedAt) < ed.config.GracePeriod {
			continue
		}

		// Get last activity time (reinforced or updated)
		lastActivity := edge.UpdatedAt
		ed.mu.RLock()
		if reinforced, ok := ed.reinforced[edge.ID]; ok && reinforced.After(lastActivity) {
			lastActivity = reinforced
		}
		ed.mu.RUnlock()

		// Calculate decayed confidence
		daysSinceActivity := now.Sub(lastActivity).Hours() / 24
		decayedConfidence := edge.Confidence * pow(ed.config.DecayRate, daysSinceActivity)

		// Check if below threshold
		if decayedConfidence < ed.config.MinConfidence {
			toDelete = append(toDelete, edge.ID)
			deleted++
		} else if decayedConfidence < edge.Confidence {
			// Confidence decayed but still above threshold - update it
			if !ed.config.DryRun {
				edge.Confidence = decayedConfidence
				if err := ed.storage.UpdateEdge(edge); err != nil {
					log.Printf("[EDGE-DECAY] Failed to update edge %s: %v", edge.ID, err)
				}
			}
			decayed++
		}
	}

	// Delete edges below threshold
	if !ed.config.DryRun {
		for _, edgeID := range toDelete {
			if err := ed.storage.DeleteEdge(edgeID); err != nil {
				log.Printf("[EDGE-DECAY] Failed to delete edge %s: %v", edgeID, err)
			} else {
				// Clean up reinforcement tracking
				ed.mu.Lock()
				delete(ed.reinforced, edgeID)
				ed.mu.Unlock()
			}
		}
	} else if len(toDelete) > 0 {
		log.Printf("[EDGE-DECAY] DRY-RUN: Would delete %d edges", len(toDelete))
	}

	// Update stats
	duration := time.Since(startTime)
	ed.stats.mu.Lock()
	ed.stats.ScansCompleted++
	ed.stats.EdgesScanned += int64(scanned)
	ed.stats.EdgesDecayed += int64(decayed)
	ed.stats.EdgesDeleted += int64(deleted)
	ed.stats.LastScanTime = startTime
	ed.stats.LastScanDuration = duration
	ed.stats.mu.Unlock()

	return scanned, decayed, deleted, nil
}

// pow calculates base^exp for float64.
func pow(base, exp float64) float64 {
	if exp == 0 {
		return 1
	}
	result := 1.0
	for i := 0; i < int(exp); i++ {
		result *= base
	}
	// Handle fractional part with approximation
	frac := exp - float64(int(exp))
	if frac > 0 {
		result *= 1 + frac*(base-1)
	}
	return result
}
